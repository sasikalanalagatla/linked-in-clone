<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Video Call</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background: #f5f5f5;
        }
        .video-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        video {
            width: 400px;
            height: 300px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #000;
            object-fit: cover;
        }
        #localVideo {
            transform: scaleX(-1);
        }
        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            transition: all 0.2s;
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        #call-button { background: #4285f4; color: white; }
        #accept-button { background: #34a853; color: white; }
        #reject-button { background: #ea4335; color: white; }
        #end-button { background: #ea4335; color: white; }
        .call-status {
            margin: 20px 0;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            min-height: 27px;
        }
        .user-name {
            margin-top: 5px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
<h2>Video Call</h2>

<div class="video-container">
    <div>
        <video id="localVideo" autoplay muted></video>
        <div class="user-name" id="localUserName">You</div>
    </div>
    <div>
        <video id="remoteVideo" autoplay></video>
        <div class="user-name" id="remoteUserName">Remote user</div>
    </div>
</div>

<div id="call-controls">
    <div class="call-status" id="call-status">Ready to call</div>
    <div class="button-container">
        <button id="call-button">Start Call</button>
        <button id="accept-button" style="display:none;">Accept</button>
        <button id="reject-button" style="display:none;">Reject</button>
        <button id="end-button" style="display:none;">End Call</button>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

<script>
    const currentUserId = 1; // Replace with actual user ID
    const targetUserId = 2; // Replace with actual target user ID

    // DOM Elements
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const callButton = document.getElementById("call-button");
    const acceptButton = document.getElementById("accept-button");
    const rejectButton = document.getElementById("reject-button");
    const endButton = document.getElementById("end-button");
    const callStatus = document.getElementById("call-status");
    const remoteUserName = document.getElementById("remoteUserName");

    // WebRTC variables
    let stompClient = null;
    let peerConnection = null;
    let localStream = null;
    let pendingOffer = null;
    let remoteUserNameValue = "";

    // State management
    const states = {
        IDLE: 'idle',
        CALLING: 'calling',
        RINGING: 'ringing',
        ACTIVE: 'active',
        ENDING: 'ending'
    };
    let currentState = states.IDLE;

    // ICE Servers configuration
    const iceServers = {
        iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
            { urls: "stun:stun2.l.google.com:19302" }
        ]
    };

    // Initialize WebSocket connection
    function connectWebSocket() {
        const socket = new SockJS('/ws');
        stompClient = Stomp.over(socket);

        stompClient.connect({}, () => {
            console.log("WebSocket connected");

            // Subscribe to video signals
            stompClient.subscribe('/user/queue/video', message => {
                const signal = JSON.parse(message.body);
                handleSignal(signal);
            });

            // Subscribe to call notifications
            stompClient.subscribe('/user/queue/call', message => {
                const notification = JSON.parse(message.body);
                console.log("Received call notification:", notification);
                handleCallNotification(notification);
            });
        }, error => {
            console.error("WebSocket error:", error);
            updateStatus("Connection error. Please refresh.");
        });
    }

    // Initialize peer connection
    function initPeerConnection() {
        if (peerConnection) {
            peerConnection.close();
        }

        peerConnection = new RTCPeerConnection(iceServers);

        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                sendSignal("candidate", event.candidate);
            }
        };

        peerConnection.ontrack = event => {
            console.log("Received remote stream");
            if (!remoteVideo.srcObject) {
                remoteVideo.srcObject = event.streams[0];
            }
        };

        peerConnection.onconnectionstatechange = () => {
            console.log("Connection state:", peerConnection.connectionState);
            if (peerConnection.connectionState === "disconnected" ||
                peerConnection.connectionState === "failed") {
                endCall();
            }
        };
    }

    // Get user media
    async function getUserMedia() {
        try {
            console.log("=== GETUSERMEDIA DEBUG ===");
            console.log("Current state when requesting media:", currentState);
            console.log("Existing localStream:", localStream);

            if (!localStream) {
                console.log("Requesting camera/microphone access...");

                // Check if getUserMedia is available
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error("getUserMedia is not supported");
                }

                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });

                console.log("Media access granted, setting local video");
                localVideo.srcObject = localStream;
            } else {
                console.log("Using existing localStream");
            }

            console.log("Final localStream:", localStream);
            console.log("=========================");
            return localStream;
        } catch (error) {
            console.error("=== GETUSERMEDIA ERROR ===");
            console.error("Error getting user media:", error);
            console.error("Error name:", error.name);
            console.error("Error message:", error.message);
            console.error("=========================");
            throw error;
        }
    }

    // Start a call (initiator)
    async function startCall() {
        try {
            console.log("Starting call...");
            changeState(states.CALLING);

            // Get user media first
            await getUserMedia();

            // Initialize peer connection
            initPeerConnection();

            // Add tracks to peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Create and send offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            // Send call request with offer
            sendCallNotification("call_request", offer);

        } catch (error) {
            console.error("Error starting call:", error);
            updateStatus("Failed to start call");
            endCall();
        }
    }

    // Accept incoming call (receiver)
    async function acceptCall() {
        try {
            console.log("Accepting call...");
            changeState(states.ACTIVE);

            // Get user media
            await getUserMedia();

            // Initialize peer connection if not already done
            if (!peerConnection) {
                initPeerConnection();
            }

            // Add tracks to peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Send acceptance notification
            sendCallNotification("call_accepted");

            // Handle pending offer if exists
            if (pendingOffer) {
                console.log("Processing pending offer");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(pendingOffer));

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                sendSignal("answer", answer);

                pendingOffer = null;
            }
        } catch (error) {
            console.error("Error accepting call:", error);
            updateStatus("Failed to accept call");
            endCall();
        }
    }

    // Reject incoming call
    function rejectCall() {
        console.log("Rejecting call");
        sendCallNotification("call_rejected");
        pendingOffer = null;
        changeState(states.IDLE);
    }

    // End current call
    function endCall() {
        if (currentState === states.ENDING || currentState === states.IDLE) return;

        console.log("Ending call");
        changeState(states.ENDING);

        // Stop all media tracks
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localVideo.srcObject = null;
            localStream = null;
        }

        // Close peer connection
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }

        // Clear remote video
        remoteVideo.srcObject = null;

        // Notify the other user if not already ending
        if (currentState !== states.IDLE) {
            sendCallNotification("call_ended");
        }

        // Reset state
        pendingOffer = null;
        setTimeout(() => {
            changeState(states.IDLE);
        }, 500);
    }

    // Handle incoming call notifications
    function handleCallNotification(notification) {
        console.log("=== NOTIFICATION DEBUG ===");
        console.log("Notification type:", notification.type);
        console.log("Current state:", currentState);
        console.log("Local video srcObject:", localVideo.srcObject);
        console.log("Local stream:", localStream);
        console.log("========================");

        if (notification.senderName && notification.senderName !== "You") {
            remoteUserName.textContent = notification.senderName;
            remoteUserNameValue = notification.senderName;
        }

        switch (notification.type) {
            case "call_request":
                if (currentState === states.IDLE) {
                    console.log("===============================");
                } else {
                    // Busy - reject the call
                    console.log("Rejecting call - busy");
                    sendCallNotification("call_rejected");
                }
                break;

            case "call_accepted":
                if (currentState === states.CALLING) {
                    console.log("Call accepted");
                    changeState(states.ACTIVE);
                }
                break;

            case "call_rejected":
                if (currentState === states.CALLING) {
                    console.log("Call rejected");
                    updateStatus(`${remoteUserNameValue || 'User'} rejected your call`);
                    endCall();
                }
                break;

            case "call_ended":
                if (currentState !== states.IDLE && currentState !== states.ENDING) {
                    console.log("Call ended by remote user");
                    updateStatus(`${remoteUserNameValue || 'User'} ended the call`);
                    endCall();
                }
                break;
        }
    }== INCOMING CALL PROCESSING ===");
                    console.log("Before processing - Local video srcObject:", localVideo.srcObject);

                    // Store the offer but DON'T process it yet
                    if (notification.payload) {
                        try {
                            pendingOffer = typeof notification.payload === 'string'
                                ? JSON.parse(notification.payload)
                                : notification.payload;
                            console.log("Stored pending offer");
                        } catch (e) {
                            console.error("Error parsing offer:", e);
                            pendingOffer = notification.payload;
                        }
                    }


                    console.log("Changing to RINGING state - NO media should be accessed");
                    changeState(states.RINGING);
                    updateStatus(`Incoming call from ${notification.senderName || 'User'}`);

                    console.log("After processing - Local video srcObject:", localVideo.srcObject);
                    console.log("After processing - Local stream:", localStream);
                    console.log("=

    // Handle WebRTC signaling
    async function handleSignal(signal) {
        try {
            console.log("Handling signal:", signal.type);

            if (!peerConnection) {
                console.log("No peer connection, ignoring signal");
                return;
            }

            let payload;
            try {
                payload = typeof signal.payload === 'string'
                    ? JSON.parse(signal.payload)
                    : signal.payload;
            } catch (e) {
                console.error("Error parsing signal payload:", e);
                return;
            }

            if (signal.type === "offer") {
                console.log("Received offer");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(payload));

                if (currentState === states.ACTIVE) {
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    sendSignal("answer", answer);
                }
            }
            else if (signal.type === "answer") {
                console.log("Received answer");
                await peerConnection.setRemoteDescription(new RTCSessionDescription(payload));
            }
            else if (signal.type === "candidate") {
                console.log("Received ICE candidate");
                await peerConnection.addIceCandidate(new RTCIceCandidate(payload));
            }
        } catch (error) {
            console.error("Error handling signal:", error);
        }
    }

    // Send WebRTC signal
    function sendSignal(type, payload) {
        if (!stompClient) {
            console.error("WebSocket not connected");
            return;
        }

        const signalMessage = {
            type: type,
            senderId: currentUserId.toString(),
            receiverId: targetUserId.toString(),
            payload: JSON.stringify(payload)
        };

        console.log("Sending signal:", type);
        stompClient.send("/app/video.signal", {}, JSON.stringify(signalMessage));
    }

    // Send call notification
    function sendCallNotification(type, payload = null) {
        if (!stompClient) {
            console.error("WebSocket not connected");
            return;
        }

        const notification = {
            type: type,
            senderId: currentUserId.toString(),
            receiverId: targetUserId.toString(),
            senderName: "You",
            payload: payload ? JSON.stringify(payload) : null
        };

        console.log("Sending notification:", type);
        stompClient.send("/app/call.notify", {}, JSON.stringify(notification));
    }

    // Update UI based on state
    function changeState(newState) {
        console.log(`State changing from ${currentState} to ${newState}`);
        currentState = newState;

        // Reset all buttons first
        callButton.style.display = "none";
        acceptButton.style.display = "none";
        rejectButton.style.display = "none";
        endButton.style.display = "none";
        callButton.disabled = false;

        // Update UI based on state
        switch (currentState) {
            case states.IDLE:
                callButton.style.display = "inline-block";
                updateStatus("Ready to call");
                break;

            case states.CALLING:
                callButton.style.display = "inline-block";
                callButton.disabled = true;
                updateStatus("Calling...");
                break;

            case states.RINGING:
                acceptButton.style.display = "inline-block";
                rejectButton.style.display = "inline-block";
                updateStatus(`Incoming call from ${remoteUserNameValue || 'User'}`);
                break;

            case states.ACTIVE:
                endButton.style.display = "inline-block";
                updateStatus(`In call with ${remoteUserNameValue || 'User'}`);
                break;

            case states.ENDING:
                updateStatus("Ending call...");
                break;
        }
    }

    // Update status message
    function updateStatus(message) {
        callStatus.textContent = message;
    }

    // Event listeners
    callButton.addEventListener("click", startCall);
    acceptButton.addEventListener("click", acceptCall);
    rejectButton.addEventListener("click", rejectCall);
    endButton.addEventListener("click", endCall);

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (currentState !== states.IDLE) {
            endCall();
        }
    });

    // Initialize on load
    console.log("=== PAGE LOAD DEBUG ===");
    console.log("Page loaded, current protocol:", window.location.protocol);
    console.log("Page loaded, current host:", window.location.host);
    console.log("getUserMedia available:", !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia));
    console.log("Initial local video srcObject:", localVideo.srcObject);
    console.log("======================");

    connectWebSocket();
</script>
</body>
</html>